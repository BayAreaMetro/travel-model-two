"""
create_emme_network.py

Creates an Emme project folder and database and creates a scenario for each time period.
In each scenario, a network is created in accordance with the Emme transaction files
generated by the cube_to_emme_network_conversion.py script.

Usage: %EMME_PYTHON_PATH%\python create_emme_network.py
    Note that the Emme python must be used to have access to the Emme API

    [-p, --trn_path]: path to the trn folder, default is the
        current_working_folder\trn
    [-n, --name]: project folder name created in the trn folder,
        default is mtc_emme
    [-i, --first_iteration]: Is this the first iteration? yes or no,
        default is yes
    [-t, --time_periods]: List of time periods as EA,AM,MD,PM,EV or
        ALL, default is ALL
    [-o, --port]: Port to connect to Emme desktop session, default
        is 59673
    [-d, --delete]: delete / overwrite existing Emme project folder

Date: Oct, 2021
Contacts: david.hensle@rsginc.com, kevin@inrosoftware.com
"""

import os as _os
import sys as _sys

_join, _dir = _os.path.join, _os.path.dirname
root = _dir(__file__)
print("Adding {} to system path to import apply_fares".format(root))
if root not in _sys.path:
    _sys.path.append(root)
import apply_fares as _apply_fares

import inro.emme.desktop.app as _app
import inro.emme.desktop.types as _ws_types
import inro.emme.database.emmebank as _eb
import inro.modeller as _m
from inro.emme.desktop.exception import TcpConnectFailureError

import argparse as _argparse
import shutil as _shutil
import pandas as _pd
import numpy as _np
import math as _math
from collections import defaultdict as _defaultdict


# ------------- input files------------
emme_mode_transaction_file = "emme_modes.txt"
emme_vehicle_transaction_file = "emme_vehicles.txt"
emme_network_transaction_file = "emme_network.txt"
extra_node_attr_file = "emme_extra_node_attributes.txt"
extra_link_attr_file = "emme_extra_link_attributes.txt"
update_extra_link_attr_file = "emme_update_extra_link_attributes.txt"
emme_transit_network_file = "emme_transit_lines.txt"
extra_transit_line_attr_file = "emme_extra_line_attributes.txt"
extra_transit_segment_attr_file = "emme_extra_segment_attributes.txt"
emme_transit_time_function_file = "emme_transit_time_function.txt"
emme_node_network_fields_file = "emme_extra_node_network_fields.txt"
emme_link_network_fields_file = "emme_extra_link_network_fields.txt"
station_extra_attributes_file = "station_extra_attributes.txt"
station_network_fields_file= "station_network_fields.txt"
emme_node_id_xwalk_file = 'node_id_crosswalk.csv'
station_tap_attributes_file =  r'station_attributes\station_tap_attributes.csv'
tap_to_pseudo_tap_xwalk_file = _join(_os.getcwd(), 'hwy', 'tap_to_pseudo_tap_xwalk.csv')


# ------------- run parameters ---------
# _all_periods = ['AM']
_all_periods = ['EA', 'AM', 'MD', 'PM', 'EV']
# mapping time of day period to emme scenario_id
period_to_scenario_dict = {
    'EA': 1000,
    'AM': 2000,
    'MD': 3000,
    'PM': 4000,
    'EV': 5000,
}
# max distance in feet to override walk transfer links with station bus walk time
max_station_walk_distance = 500

WKT_PROJECTION = 'PROJCS["NAD_1983_StatePlane_California_VI_FIPS_0406_Feet",GEOGCS["GCS_North_American_1983",DATUM["North_American_Datum_1983",SPHEROID["GRS_1980",6378137,298.257222101]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Lambert_Conformal_Conic_2SP"],PARAMETER["False_Easting",6561666.666666666],PARAMETER["False_Northing",1640416.666666667],PARAMETER["Central_Meridian",-116.25],PARAMETER["Standard_Parallel_1",32.78333333333333],PARAMETER["Standard_Parallel_2",33.88333333333333],PARAMETER["Latitude_Of_Origin",32.16666666666666],UNIT["Foot_US",0.30480060960121924],AUTHORITY["EPSG","102646"]]'


def init_emme_project(root, title, port=59673, overwrite=False):
    """
    Creates a new Emme project and sets up the database and coordinate system.

    Parameters:
        - root: str continaing the folder location to put the Emme project
        - title: str project folder name
        - port: int specifies the port number to open the destop on
        - overwrite: boolean to decide whether to overwrite the project if it already exists
    Returns:
        - desktop: an emme desktop object for the created project
    """
    emme_dir = _os.path.join(root, title)
    if overwrite and _os.path.exists(emme_dir):
        try:
            app = _app.connect(port=port)
            app.close()
        except TcpConnectFailureError:  # no running desktop
            pass
        _shutil.rmtree(emme_dir)
    print "Creating Emme project folder with name: %s" % title
    project_path = _app.create_project(root, title)
    desktop = _app.start(  # will not close desktop when program ends
        project=project_path, user_initials="RSG", visible=True, port=port)
    # desktop = _app.start_dedicated(
    #     project=project_path, user_initials="DH", visible=True)
    project = desktop.project
    project.name = "MTC Emme Project"
    prj_file_path = _join(root, 'NAD 1983 StatePlane California VI FIPS 0406 Feet.prj')
    with open(prj_file_path, 'w') as f:
        f.write(WKT_PROJECTION)
    project.spatial_reference_file = prj_file_path
    project.initial_view = _ws_types.Box(4700000, 3450000, 4970000, 4030000)
    project_root = _dir(project_path)
    dimensions = {
        'scalar_matrices': 9999,
        'destination_matrices': 999,
        'origin_matrices': 999,
        'full_matrices': 1000,

        'scenarios': 30,
        'centroids': 6000,
        'regular_nodes': 600000,
        'links': 1000000,
        'turn_entries': 1,
        'transit_vehicles': 200,
        'transit_lines': 2000,
        'transit_segments': 2000000,
        'extra_attribute_values': 150000000,

        'functions': 99,
        'operators': 5000,
        'sola_analyses': 240
    }

    _os.mkdir(_join(project_root, "Database"))
    emmebank = _eb.create(_join(project_root, "Database", "emmebank"), dimensions)
    emmebank.title = title
    emmebank.coord_unit_length = 0.000189394  # feet to miles
    emmebank.unit_of_length = "mi"
    emmebank.unit_of_cost = "$"
    emmebank.unit_of_energy = "MJ"
    emmebank.node_number_digits = 6
    emmebank.use_engineering_notation = True
    for period, scenario_id in period_to_scenario_dict.items():
        if period not in _all_periods:
            continue
        scenario = emmebank.create_scenario(scenario_id)
        scenario.title = period
    # emmebank.dispose()

    desktop.data_explorer().add_database(emmebank.path)

    all_databases = desktop.data_explorer().databases()
    print len(all_databases), "databases in project"
    # opening first database.  There must be a better way to do this...
    for database in all_databases:
        print database.name(), len(database.scenarios())
        database.open()
        break
    project.save()
    return desktop


def import_modes(input_dir, modeller, scenario_id):
    """
    Read the mode transaction file into the Emme project

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
    Returns: None
    """
    print "importing modes"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)
    process_modes_tool_path = "inro.emme.data.network.mode.mode_transaction"
    process_modes_tool = modeller.tool(process_modes_tool_path)
    input_file = _join(input_dir, emme_mode_transaction_file)
    process_modes_tool(transaction_file=input_file,
        revert_on_error=False,
        scenario=scenario)


def import_network(input_dir, modeller, scenario_id):
    """
    Read the network transaction file into the Emme project

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
    Returns: None
    """
    print "importing network"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)
    process_network_tool_path = "inro.emme.data.network.base.base_network_transaction"
    process_network_tool = modeller.tool(process_network_tool_path)
    input_file = _join(input_dir, emme_network_transaction_file)
    process_network_tool(transaction_file=input_file,
        revert_on_error=False,
        scenario=scenario)


def import_extra_node_attributes(input_dir, modeller, scenario_id):
    """
    Read the extra node attributes transaction file into the Emme project

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
    Returns: None
    """
    print "importing node attributes"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)
    import_extra_attributes_tool_path = "inro.emme.data.extra_attribute.import_extra_attributes"
    import_extra_attributes_tool = modeller.tool(import_extra_attributes_tool_path)
    input_file = _join(input_dir, extra_node_attr_file)
    import_extra_attributes_tool(
        file_path=input_file,
        scenario=scenario,
        field_separator=",",
        has_header=True,
        column_labels="FROM_HEADER",
        import_definitions=True,
        revert_on_error=False
    )


def import_extra_link_attributes(input_dir, modeller, scenario_id, update=False):
    """
    Read the extra link attributes transaction file into the Emme project

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
        - update: boolean to determine whether to just load extra link attributes or
            also load the network fields.  Should be True if not the first model iteration
    Returns: None
    """
    print "importing link attributes"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)

    # importing numeric attributes
    import_extra_attributes_tool_path = "inro.emme.data.extra_attribute.import_extra_attributes"
    import_extra_attributes_tool = modeller.tool(import_extra_attributes_tool_path)
    input_file = _join(input_dir, extra_link_attr_file)
    # currently re-importing all link attributes
    # if update:
    #     input_file = _join(input_dir, update_extra_link_attr_file)
    import_extra_attributes_tool(
        file_path=input_file,
        scenario=scenario,
        field_separator=",",
        has_header=True,
        column_labels="FROM_HEADER",
        import_definitions=True,
        revert_on_error=False
    )

    # importing string attributes
    if update:
        # don't need to re-import on update
        return
    import_network_fields_tool_path = "inro.emme.data.network_field.import_network_fields"
    import_network_fields_tool = modeller.tool(import_network_fields_tool_path)
    input_file = _join(input_dir, emme_link_network_fields_file)
    # currently re-importing all link attributes
    # if update:
    #     input_file = _join(input_dir, update_extra_link_attr_file)
    import_network_fields_tool(
        file_path=input_file,
        scenario=scenario,
        field_separator=",",
        has_header=True,
        column_labels="FROM_HEADER",
        import_definitions=True,
        revert_on_error=False
    )



def import_vehicles(input_dir, modeller, scenario_id):
    """
    Read the transit vehicle transaction file into the Emme project

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
    Returns: None
    """
    print "importing transit vehicles"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)
    process_vehicles_tool_path = "inro.emme.data.network.transit.vehicle_transaction"
    process_vehicles_tool = modeller.tool(process_vehicles_tool_path)
    input_file = _join(input_dir, emme_vehicle_transaction_file)
    process_vehicles_tool(transaction_file=input_file,
        revert_on_error=False,
        scenario=scenario)


def import_transit_time_functions(input_dir, modeller, scenario_id):
    """
    Read the transit time functions transaction file into the Emme project

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
    Returns: None
    """
    print "importing transit time functions"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)
    process_functions_tool_path = "inro.emme.data.function.function_transaction"
    process_functions_tool = modeller.tool(process_functions_tool_path)
    input_file = _join(input_dir, emme_transit_time_function_file)
    process_functions_tool(
        transaction_file=input_file,
        throw_on_error=True)


def import_transit_lines(input_dir, modeller, scenario_id):
    """
    Read the transit newtwork transaction file into the Emme project

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
    Returns: None
    """
    print "importing transit network"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)
    process_transit_lines_tool_path = "inro.emme.data.network.transit.transit_line_transaction"
    process_transit_lines_tool = modeller.tool(process_transit_lines_tool_path)
    input_file = _join(input_dir, emme_transit_network_file)
    process_transit_lines_tool(transaction_file=input_file,
        revert_on_error=True,
        scenario=scenario,
        include_first_hidden_data=False)


def import_extra_transit_line_attributes(input_dir, modeller, scenario_id):
    """
    Read the extra transit line attributes transaction file into the Emme project

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
    Returns: None
    """
    print "importing extra transit line attributes"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)
    import_extra_attributes_tool_path = "inro.emme.data.extra_attribute.import_extra_attributes"
    import_extra_attributes_tool = modeller.tool(import_extra_attributes_tool_path)
    input_file = _join(input_dir, extra_transit_line_attr_file)
    import_extra_attributes_tool(
        file_path=input_file,
        scenario=scenario,
        field_separator=",",
        has_header=True,
        column_labels="FROM_HEADER",
        import_definitions=True,
        revert_on_error=False
    )


def import_extra_transit_segment_attributes(input_dir, modeller, scenario_id):
    """
    Read the extra transit segment attributes transaction file into the Emme project

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
    Returns: None
    """
    print "importing extra transit segment attributes"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)
    import_extra_attributes_tool_path = "inro.emme.data.extra_attribute.import_extra_attributes"
    import_extra_attributes_tool = modeller.tool(import_extra_attributes_tool_path)
    input_file = _join(input_dir, extra_transit_segment_attr_file)
    import_extra_attributes_tool(
        file_path=input_file,
        scenario=scenario,
        field_separator=",",
        has_header=True,
        column_labels="FROM_HEADER",
        import_definitions=True,
        revert_on_error=False
    )


def import_station_attributes(input_dir, modeller, scenario_id):
    """
    Read the station attributes and network fields transaction files into the Emme project.

    Parameters:
        - input_dir: str folder location of mode transaction file
        - modeller: Emme Modeller instance for current project
        - scenario_id: int specifying scenario to import into
    Returns: None
    """
    print "importing station attributes"
    if modeller is None:
        modeller = _m.Modeller()
    scenario = modeller.emmebank.scenario(scenario_id)

    # importing numeric attributes
    import_extra_attributes_tool_path = "inro.emme.data.extra_attribute.import_extra_attributes"
    import_extra_attributes_tool = modeller.tool(import_extra_attributes_tool_path)
    input_file = _join(input_dir, station_extra_attributes_file)
    import_extra_attributes_tool(
        file_path=input_file,
        scenario=scenario,
        field_separator=",",
        has_header=True,
        column_labels="FROM_HEADER",
        import_definitions=True,
        revert_on_error=False
    )

    import_network_fields_tool_path = "inro.emme.data.network_field.import_network_fields"
    import_network_fields_tool = modeller.tool(import_network_fields_tool_path)
    input_file = _join(input_dir, station_network_fields_file)
    import_network_fields_tool(
        file_path=input_file,
        scenario=scenario,
        field_separator=",",
        has_header=True,
        column_labels="FROM_HEADER",
        import_definitions=True,
        revert_on_error=False
    )


def replace_route_for_lines_with_nntime_and_created_segments(network, input_dir):
    """
    For routes that operate on a fixed guideway and are not routed on the network,
    this method will create the emme links and route the network on them.  This is not
    currently used because the input network already contains the fixed guideway links.
    It is left here incase that changes in the future.

    Parameters:
        - network: Emme network object on which to make the transit line
        - input_dir: str folder Location of the transit line data and stop information
    Returns:
        - None (the network object is updated)
    """
    stop_attributes_path = _join(input_dir, 'all_stop_attributes.csv')
    stop_attributes_df = _pd.read_csv(stop_attributes_path)
    transit_line_path = _join(input_dir, 'lines_that_need_links_created.csv')
    transit_line_df = _pd.read_csv(transit_line_path)

    with _m.logbook_trace("Creating links for specified transit lines"):
        for idx, line in transit_line_df.iterrows():
            if line['keep_line'] == 0:
                continue
            print "Creating line %s (%s) with new links" % (line['line_name'], line['LINE'])
            transit_line = network.transit_line(line['line_name'])
            if transit_line is not None:
                network.delete_transit_line(line['line_name'])
            stops_for_line = stop_attributes_df[stop_attributes_df['LINE'] == line['LINE']]
            transit_vehicle = network.transit_vehicle(line['vehicle'])
            line_mode = transit_vehicle.mode

            for idx, stop in stops_for_line.iterrows():
                if _pd.isna(stop['next_node_id']):
                    # no more stops
                    break
                link = network.link(stop['node_id'], stop['next_node_id'])
                if link is None:
                    print "link from %s to %s doesn't exist, creating new link" % \
                        (stop['node_id'], stop['next_node_id'])
                    link = network.create_link(stop['node_id'], stop['next_node_id'], set([line_mode]))
                    link.length = link.shape_length
                    link['@trantime'] = link.length / line['XYSPEED'] * 60  # mi / mph * 60 min/mi = min
            network.create_transit_line(line['line_name'], transit_vehicle.id, list(stops_for_line['node_id'].values))

            # setting extra attributes
            new_line = network.transit_line(line['line_name'])
            new_line['@headway1'] = line['HEADWAY[1]']
            new_line['@headway2'] = line['HEADWAY[2]']
            new_line['@headway3'] = line['HEADWAY[3]']
            new_line['@headway4'] = line['HEADWAY[4]']
            new_line['@headway5'] = line['HEADWAY[5]']
            new_line['headway'] = line['headway']
            new_line['description'] = line['descr']
            new_line['@uses_nntime'] = line['uses_NNTIME']
            new_line['speed'] = line['speed']
            new_line['@faresystem'] = line['FARESYSTEM']
            new_line['@line_mode'] = line['MODE']



def fill_transit_times_for_created_segments(network):
    """
    Method to set the transit segment transit time to the congested time of the link
    it travels on.  This method should be unnessesary as the segment times should be
    included in the extra segment attributes transaction file.

    Parameters:
        - network: Emme network object to update transit segment times on
    Returns:
        - None
    """
    segments_fixed = 0
    lines_with_created_segments = []

    for line in network.transit_lines():
        for segment in line.segments(include_hidden=False):
            if segment['@link_trantime'] == 0:
                seg_link = segment.link
                segment['@link_trantime'] = seg_link['@trantime']
                segments_fixed += 1
                if line.id not in lines_with_created_segments:
                    lines_with_created_segments.append(line.id)
    print "Number of transit lines modified: %s" % len(lines_with_created_segments)
    print "Number of created segments assigned link trantime: %s" % segments_fixed


def distribute_nntime_among_segments(segments_for_current_nntime, nntime):
    """
    Distributes the NNTIME among the selected segments for that NNTIME by length of the segments

    Parameters:
        - segments_for_current_nntime: list of Emme transit segments
        - nntime: float that specifys NNTIME for those segments
    Returns:
        - None (network segment attributes are set)
    """
    total_length = 0
    for segment in segments_for_current_nntime:
        total_length += segment.link.length

    for segment in segments_for_current_nntime:
        segment['@tot_nntime'] = nntime
        segment['@nn_trantime'] = nntime * (segment.link.length / total_length)
        # segment['@nn_trantime'] = segment['@tot_nntime'] * (segment.link.length / total_length)
        # new_nn_trantime = segment['@tot_nntime'] * (segment.link.length / total_length)
        # print "Segment: %s, total_length: %s, length: %s, tot_nntime: %s, nn_trantime: %s," % \
        #     (segment.id, total_length, segment.link.length, segment['@tot_nntime'], segment['@nn_trantime'])


def distribute_nntime(network, input_dir):
    """
    Sets the station-to-station time (NNTIME in Cube lingo) for the transit segments.
    First grabs the segments that belong to each particular NNTIME entry and
    distributes the NNTIME to the segments according to the segment lengths. If there is
    only one link for the NNTIME, that link is given the entire NNTIME.

    Parameters:
        - network: Emme network object to set NNTIME on
        - input_dir: str folder location containing the stop attributes that specify nntime
    Returns:
        - None (network object is updated)
    """
    stop_attributes_path = _join(input_dir, 'all_stop_attributes.csv')
    stop_attributes_df = _pd.read_csv(stop_attributes_path)

    print "Setting transit station-to-station times (NNTIME in Cube)"

    for line in network.transit_lines():
        if (line['@uses_nntime'] == 0):
            continue
        # print "distributing NNTIME for line %s" % line.id
        segments_for_current_nntime = []
        for segment in line.segments(include_hidden=False):
            # i_node = segment.link.i_node
            # do not include tap connectors in nn_time calculation
            if (segment.link['@ntl_mode'] != 0) | ((segment.link['length'] == 0)):
                continue
            j_node = segment.link.j_node
            segments_for_current_nntime.append(segment)

            nntime_df = stop_attributes_df.loc[
                (stop_attributes_df['NAME'] == line.id)
                & (stop_attributes_df['node_id'] == int(j_node)),
                'NNTIME'
            ]
            # print "%s" % nntime_df
            if nntime_df.notna().any():
                nntime = nntime_df.values[0]
                # NNTIME applies to all segments ending at node_id
                # print "Distributing %s NNTIME among %s segments " % \
                    # (nntime, len(segments_for_current_nntime))
                distribute_nntime_among_segments(segments_for_current_nntime, nntime)
                segments_for_current_nntime = []


def fix_bad_walktimes(network):
    """
    Removes walk links that are longer than 0.25 miles and overrides walk links that
    erroneously have a length of 2 feet.  With newer versions of the network and code,
    this method should no longer be needed as these links shouldn't be created in the
    first place.

    Parameters:
        - network: Emme network object containing the bad walk links
    Returns:
        - None (network object is updated)
    """
    for link in network.links():
        if link['@ntl_mode'] != 2:
            continue
        if link.shape_length > .25:
            network.delete_link(link)
            continue
        if link['@feet'] == 2:
            link.length = link.shape_length
            link['@walktime'] = link.length / 3 * 60  # mi / 3mph * 60 min/hr = walktime in mins
            link.data2 = link['@walktime']


def split_tap_connectors_to_prevent_walk(network):
    """
    Splits the tap connectors into two segments. Transit lines connected to that tap
    are routed through the first segment, but not the segment connecting to the tap which only has
    access/egress walk allowed. Boarding conditions are set on the transit route to prevent people
    from being able to walk from the tap directly onto the network without boarding the transit line
    and taking if for at least one stop.

    Parameters:
        - network: Emme network object to split the tap connectors on
    Returns:
        - None (network object is updated)
    """
    print "Splitting Tap Connectors"
    tap_stops = _defaultdict(lambda: [])
    new_node_id = init_node_id(network)
    all_transit_modes = set([mode for mode in network.modes() if mode.type == "TRANSIT"])
    node_attributes = network.attributes("NODE")
    node_attributes.remove("x")
    node_attributes.remove("y")

    access_mode = set([network.mode("a")])
    transfer_mode =  network.mode("w")
    egress_mode =  set([network.mode("e")])

    # Mark TAP adjacent stops and split TAP connectors
    for centroid in network.centroids():
        out_links = list(centroid.outgoing_links())
        in_links = list(centroid.incoming_links())
        for link in out_links + in_links:
            link.length = 0.0005  # setting length so that connector access time = 0.01
        for link in out_links:
            real_stop = link.j_node
            has_adjacent_transfer_links = False
            has_adjacent_walk_links = False
            for stop_link in real_stop.outgoing_links():
                if stop_link == link.reverse_link:
                    continue
                if transfer_mode in stop_link.modes :
                    has_adjacent_transfer_links = True
                if egress_mode in stop_link.modes :
                    has_adjacent_walk_links = True

            if has_adjacent_transfer_links or has_adjacent_walk_links:
                length = link.length
                new_node_id += 1
                tap_stop = network.split_link(centroid, real_stop, new_node_id, include_reverse=True, proportion=0.5)
                for attr in node_attributes:
                    tap_stop[attr] = real_stop[attr]
                # tap_stop["@network_adj"] = 1
                tap_stops[real_stop].append(tap_stop)
                transit_access_link = network.link(real_stop, tap_stop)
                for link in transit_access_link, transit_access_link.reverse_link:
                    link.modes = all_transit_modes
                    # set attributes such this link has no transit time or length associated to it
                    link.length = 0
                    link.data1 = 0
                    link.data2 = 0
                    link.data3 = 0
                    link['@trantime'] = 0
                    # for p in ["ea", "am", "md", "pm", "ev"]:
                    #     link["@time_link_" + p] = 0
                egress_link = network.link(tap_stop, centroid)
                egress_link.modes = egress_mode
                egress_link.reverse_link.modes = access_mode
                egress_link.length = length
                egress_link.reverse_link.length = length

    line_attributes = network.attributes("TRANSIT_LINE")
    seg_attributes = network.attributes("TRANSIT_SEGMENT")
    seg_invehicle_attrs = ["@invehicle_cost"]

    # re-route the transit lines through the new TAP-stops
    for line in network.transit_lines():
        # store segment data for re-routing
        seg_data = {}
        itinerary = []
        tap_segments = []

        for seg in line.segments(include_hidden=True):
            seg_data[(seg.i_node, seg.j_node, seg.loop_index)] = dict((k, seg[k]) for k in seg_attributes)

            itinerary.append(seg.i_node.number)
            if seg.i_node in tap_stops and (seg.allow_boardings or seg.allow_alightings):
                # insert tap_stop, real_stop loop after tap_stop
                real_stop = seg.i_node
                tap_access = []
                tap_egress = []
                for tap_stop in tap_stops[real_stop]:
                    itinerary.extend([tap_stop.number, real_stop.number])
                    tap_access.append(len(itinerary) - 3)
                    tap_egress.append(len(itinerary) - 2)
                real_seg = len(itinerary) - 1
                # track new segments to update stopping pattern
                tap_segments.append({
                    "access": tap_access,
                    "egress": tap_egress,
                    "real": real_seg
                })

        if tap_segments:
            # store line data for re-routing
            line_data = dict((k, line[k]) for k in line_attributes)
            line_data["id"] = line.id
            line_data["vehicle"] = line.vehicle
            # delete old line, then re-create on new, re-routed itinerary
            network.delete_transit_line(line)

            new_line = network.create_transit_line(
                line_data.pop("id"),
                line_data.pop("vehicle"),
                itinerary)
            # copy line attributes back
            for k, v in line_data.iteritems():
                new_line[k] = v
            # copy segment attributes back
            for seg in new_line.segments(include_hidden=True):
                data = seg_data.get((seg.i_node, seg.j_node, seg.loop_index), {})
                for k, v in data.iteritems():
                    seg[k] = v
            # set boarding, alighting and dwell time on new tap access / egress segments
            for tap_ref in tap_segments:
                real_seg = new_line.segment(tap_ref["real"])
                for access_ref in tap_ref["access"]:
                    access_seg = new_line.segment(access_ref)
                    for k in seg_attributes:
                        access_seg[k] = real_seg[k]
                    access_seg.allow_boardings = False
                    access_seg.allow_alightings = False
                    access_seg.transit_time_func = 1  # special 0-cost ttf
                    for attr_name in seg_invehicle_attrs:
                        access_seg[attr_name] = 0
                    access_seg.dwell_time = 0

                first_access_seg = new_line.segment(tap_ref["access"][0])
                first_access_seg.allow_alightings = real_seg.allow_alightings
                first_access_seg.dwell_time = real_seg.dwell_time

                for egress_ef in tap_ref["egress"]:
                    egress_seg = new_line.segment(egress_ef)
                    for k in seg_attributes:
                        egress_seg[k] = real_seg[k]
                    egress_seg.allow_boardings = real_seg.allow_boardings
                    egress_seg.allow_alightings = real_seg.allow_alightings
                    egress_seg.transit_time_func = 1  # special 0-cost ttf
                    for attr_name in seg_invehicle_attrs:
                        egress_seg[attr_name] = 0
                    egress_seg.dwell_time = 0

                real_seg.allow_alightings = False
                real_seg.dwell_time = 0


def init_node_id(network):
    """
    Helper function to retreive an unused node_id from the network

    Parameters:
        - network: Emme network object
    Returns:
        - new_node_id: int of an unused node_id from the network
    """
    new_node_id = max(n.number for n in network.nodes())
    new_node_id = _math.ceil(new_node_id / 10000.0) * 10000
    return new_node_id


def update_transit_times(network):
    """
    Choosing whether to use the nntime for the segment transit time or use the
    congested travel time on the link.  Segments on the split tap connectors have
    length zero and have no transit time.

    Parameters:
        - network: Emme network object
    Returns:
        - None (network object is updated)
    """
    # if nntime exists, use that for ivtt, else use the link trantime
    for line in network.transit_lines():
        for segment in line.segments(include_hidden=False):
            if segment.link.length == 0:  # exclude routing on slit tap connectors
                segment['@trantime_final'] = 0
            elif segment['@nn_trantime'] > 0:
                segment['@trantime_final'] = segment['@nn_trantime']
            else:
                segment['@trantime_final'] = segment['@link_trantime']
            segment.data1 = segment['@trantime_final']
            segment.transit_time_func = 2  # tf2 = us1 (data1)


def calc_link_unreliability(network, period):
    """
    Sets the link unreliability factor for transit services routed on those links.

    Parameters:
        - network: Emme network object to set link unreliability on
        - period: str specifying time of day period to determine peak or off-peak
    Returns:
        - None (link unreliability is set on network)
    """
    AT_to_area_type_dict = {
    # AT gets set in codeLinkAreaType.py script
        0: 'CBD',  # regional core
        1: 'CBD',  # CBD
        2: 'UBD', # urban business
        3: 'URBAN', # urban
        4: 'SUBURBAN', # suburban
        5: 'RURAL', # rural
        -1: 'UBD', #CRRAIL and TAP links
    }

    FT_to_facility_type_dict = {
        1: 'FREEWAY', # freeway
        2: 'FREEWAY', # expressway
        3: 'PRIMARY', # ramp
        4: 'PRIMARY', # divided arterial
        5: 'PRIMARY', # undivided arterial
        6: 'SECONDARY', # collector
        7: 'SECONDARY', # local
        8: 'SECONDARY', # centroid connector
        99: 'SECONDARY', # dummy
        0: 'SECONDARY', # walk links, AT is set to RURAl for them so they get 0
    }

    # factor table from LA Metro CCR Summary Report page 4-10
    # found here: https://app.box.com/file/695415124876?s=okcovqhetmqfd8o0mtuucxjtolmtq9j7
    factor_table = {
        "PEAK": {
            "FREEWAY":   {"CBD": 0.24, "UBD": 0.24, "URBAN": 0.16, "SUBURBAN": 0.08, "RURAL": 0.00},
            "PRIMARY":   {"CBD": 0.22, "UBD": 0.15, "URBAN": 0.10, "SUBURBAN": 0.05, "RURAL": 0.00},
            "SECONDARY": {"CBD": 0.11, "UBD": 0.08, "URBAN": 0.05, "SUBURBAN": 0.03, "RURAL": 0.00},
            "ROW":       {"CBD": 0.09, "UBD": 0.06, "URBAN": 0.04, "SUBURBAN": 0.02, "RURAL": 0.00},
            "RAIL":      {"CBD": 0.05, "UBD": 0.03, "URBAN": 0.02, "SUBURBAN": 0.01, "RURAL": 0.00},
        },
        "OFF_PEAK": {
            "FREEWAY":   {"CBD": 0.33, "UBD": 0.33, "URBAN": 0.22, "SUBURBAN": 0.11, "RURAL": 0.00},
            "PRIMARY":   {"CBD": 0.33, "UBD": 0.24, "URBAN": 0.16, "SUBURBAN": 0.08, "RURAL": 0.00},
            "SECONDARY": {"CBD": 0.17, "UBD": 0.12, "URBAN": 0.08, "SUBURBAN": 0.04, "RURAL": 0.00},
            "ROW":       {"CBD": 0.13, "UBD": 0.10, "URBAN": 0.06, "SUBURBAN": 0.03, "RURAL": 0.00},
            "RAIL":      {"CBD": 0.07, "UBD": 0.05, "URBAN": 0.03, "SUBURBAN": 0.02, "RURAL": 0.00},
        }
    }
    if period in ["AM", "PM"]:
        factor_table = factor_table["PEAK"]
    else:
        factor_table = factor_table["OFF_PEAK"]

    for link in network.links():
        facility_type = FT_to_facility_type_dict[link['@ft']]
        area_type = AT_to_area_type_dict[link['@at']]

        if (link['#cntype'] in ['TAP', 'TRWALK']) | (link['@ft'] == 8):
            area_type = 'RURAL' # no link unreliability for connectors
        if link['#cntype'] == 'CRAIL':
            for segment in link.segments():
                line_mode = segment.line.mode
                if line_mode == 'h':
                    facility_type = 'RAIL' # heavy rail
                if line_mode in ['r', 'c', 'f']:
                    facility_type = 'ROW'
                break

        link.data3 = factor_table[facility_type][area_type]


def apply_station_attributes(input_dir, network):
    """
    Sets the station attributes onto the network.

    Rail lines with stops at stations have the station platform time set as a
    node attribute.

     Walk transfers are routed onto separate transfer nodes (aka "pseudo taps") created
     in BuildTransitNetworks.job, and not through the actual taps.
     Thus, station attributes that set walk times need to be set on the transfer node
     connectors instead of the regular tap connectors.  Walk times for these
     connectors are overwritten with the appropriate station walk times.

    Parameters:
        - input_dir: folder location of the station attribute data for this time period
        - network: Emme network object to set the station attributes on
    Returns:
        - None (network object is updated)
    """
    # reading input data
    station_tap_attributes = _pd.read_csv(_join(input_dir, station_tap_attributes_file))
    emme_node_id_xwalk = _pd.read_csv(_join(input_dir, emme_node_id_xwalk_file))
    tap_to_pseudo_tap_xwalk = _pd.read_csv(tap_to_pseudo_tap_xwalk_file, names=['tap', 'pseudo_tap'])

    # buiding crosswalk between emme taps to their pseduo walk taps
    tap_and_pseudo_tap_nodes = (
        emme_node_id_xwalk['OLD_NODE'].isin(tap_to_pseudo_tap_xwalk['tap'])
        | emme_node_id_xwalk['OLD_NODE'].isin(tap_to_pseudo_tap_xwalk['pseudo_tap']))

    emme_node_id_map = emme_node_id_xwalk[tap_and_pseudo_tap_nodes].set_index(
            ['OLD_NODE'])['node_id'].to_dict()

    tap_to_pseudo_tap_xwalk['emme_tap'] = tap_to_pseudo_tap_xwalk['tap'].map(emme_node_id_map)
    tap_to_pseudo_tap_xwalk['emme_pseudo_tap'] = tap_to_pseudo_tap_xwalk['pseudo_tap'].map(emme_node_id_map)


    # only need to loop over taps matched to stations
    station_taps = station_tap_attributes['tap'].unique()
    stop_nodes_with_platform_time = []
    bus_transfer_walk_links_overridden = []
    tap_connectors_with_platform_time = []
    # getting node attributes for created transfer nodes
    node_attributes = network.attributes("NODE")
    node_attributes.remove("x")
    node_attributes.remove("y")
    print("Node attributes: ", node_attributes)
    link_attributes = network.attributes("LINK")
    print("Link attributes: ", link_attributes)
    new_node_id = init_node_id(network)

    for tap_id in station_taps:
        # modifying station platform times for lines departing from tap
        tap = network.node(tap_id)
        tap_modes_serviced = []
        for link in tap.outgoing_links():
            jnode = link.j_node
            modes_serviced = list(set([str(segment.line['#src_mode']) for segment in jnode.outgoing_segments()]))
            tap_modes_serviced += modes_serviced
            # setting tap station platform time on tap connector nodes for stops servicing rail
            if any(x in modes_serviced for x in ['r', 'l', 'h', 'f']) & (link['@feet'] < max_station_walk_distance):
                # print "tap: %s, boarding_node: %s, stplatformtime: %s," % (tap, jnode, tap['@stplatformtime'])
                # jnode['@stnplatformtime'] = tap['@stplatformtime']
                link['@trantime'] = tap['@stplatformtime'] / 60 # convert to mins
                link.data2 = tap['@stplatformtime'] / 60  # ul2, set for time seen in transnsit assignment
                incoming_link = link.reverse_link
                incoming_link['@trantime'] = tap['@stplatformtime'] / 60
                incoming_link.data2 = tap['@stplatformtime'] / 60 # ul2
                tap_connectors_with_platform_time.append(jnode.id)


        # want to add transfer penalty between different rail modes and bus to rail
        transfer_node_id = tap_to_pseudo_tap_xwalk.loc[tap_to_pseudo_tap_xwalk['emme_tap'] == tap_id, 'emme_pseudo_tap']
        transfer_node = network.node(transfer_node_id)
        new_tnode_mode_dict = {}

        # treaing buses and express busses the same for transfers
        tap_modes_serviced = ['b' if mode == 'x' else mode for mode in tap_modes_serviced]
        tap_modes_serviced = list(set(tap_modes_serviced)) # unique entries
        # only need to split transfer node if tap serves more than one mode and has a station platform time
        if (len(tap_modes_serviced) > 1) & (tap['@stplatformtime'] > 0):
            print 'Splitting transfer nodes for tap',  tap_id, 'with modes', tap_modes_serviced
            for mode_count, mode in enumerate(tap_modes_serviced):
                # duplicate transfer node with an offset
                new_node_id += 1
                new_tnode = network.create_node(new_node_id, is_centroid=False)
                new_tnode_mode_dict[mode] = new_node_id  # store node to mode xwalk for intra-tap transfers
                for attr in node_attributes:
                    new_tnode[attr] = transfer_node[attr]

                def get_new_node_coordinates(point_num, old_x, old_y, radius, total_points):
                    # distribute points evenly around a sphere
                    angle_between_points = 2 * _math.pi / total_points
                    angle_for_point = point_num * angle_between_points
                    point_x = old_x + (radius * _math.cos(angle_for_point))
                    point_y = old_y + (radius * _math.sin(angle_for_point))
                    return list([point_x, point_y])

                new_coords = get_new_node_coordinates(
                    mode_count, transfer_node.x, transfer_node.y, 7, len(tap_modes_serviced))
                new_tnode.x = new_coords[0]
                new_tnode.y = new_coords[1]
                print 'Created node ', new_node_id, 'at x = ', new_coords[0], 'and y = ', new_coords[1]

                # re-create all relevant outgoing transfer links
                for transfer_link in transfer_node.outgoing_links():
                    # see if this transfer link connects to a node that services transit lines
                    modes_at_stop = [str(segment.line['#src_mode']) for segment in transfer_link.j_node.outgoing_segments()]
                    modes_at_stop = list(set(['b' if stop_mode == 'x' else stop_mode for stop_mode in modes_at_stop]))
                    print 'mode: ', mode, ' modes_at_stop: ', modes_at_stop
                    if (transfer_link.j_node.id in tap_to_pseudo_tap_xwalk['emme_pseudo_tap'].astype('string').values):
                        print 'connects to transfer node'
                    if (mode in modes_at_stop) | (transfer_link.j_node.id in tap_to_pseudo_tap_xwalk['emme_pseudo_tap'].astype('string').values):
                        # create new link if this tranfer node services the mode or connects to another transfer node
                        new_transfer_link = network.create_link(new_tnode.id, transfer_link.j_node, transfer_link.modes)
                        for attr in link_attributes:
                            new_transfer_link[attr] = transfer_link[attr]
                        print 'created link'

                # re-create all relevant incoming transfer links
                for transfer_link in transfer_node.incoming_links():
                    # see if this transfer link connects to a node that services transit lines
                    modes_at_stop = [str(segment.line['#src_mode']) for segment in transfer_link.i_node.outgoing_segments()]
                    modes_at_stop = list(set(['b' if stop_mode == 'x' else stop_mode for stop_mode in modes_at_stop]))
                    print 'mode: ', mode, ' modes_at_stop: ', modes_at_stop
                    if (transfer_link.i_node.id in tap_to_pseudo_tap_xwalk['emme_pseudo_tap'].astype('string').values):
                        print 'connects to transfer node'
                    if (mode in modes_at_stop) | (transfer_link.i_node.id in tap_to_pseudo_tap_xwalk['emme_pseudo_tap'].astype('string').values):
                        # create new link if this tranfer node services the mode or connects to another transfer node
                        new_transfer_link = network.create_link(transfer_link.i_node, new_tnode.id, transfer_link.modes)
                        for attr in link_attributes:
                            new_transfer_link[attr] = transfer_link[attr]
                        print 'created link'

            # all old transfer links are replaced and need to be deleted
            for transfer_link in transfer_node.outgoing_links():
                network.delete_link(transfer_link.i_node, transfer_link.j_node)
            for transfer_link in transfer_node.incoming_links():
                network.delete_link(transfer_link.i_node, transfer_link.j_node)
            network.delete_node(transfer_node_id)

        # need to connect newly created transfer nodes to eachother
        for mode, tnode_id in new_tnode_mode_dict.iteritems():
            for next_mode, next_tnode_id in new_tnode_mode_dict.iteritems():
                if tnode_id == next_tnode_id:
                    # don't need to connect transfer node to itself
                    continue
                new_link = network.create_link(tnode_id, next_tnode_id, set(['w']));
                new_link.length = 0
                new_link['@walkdist'] = 0
                new_link['#cntype'] = 'TRWALK'
                new_link['#modes'] = 'w'
                new_link.volume_delay_func = 1
                if ((mode == 'b') & (next_mode in ['r', 'l', 'h', 'f'])  # excluding 'x' since it was already transformed to 'b'
                   | (next_mode == 'b') & (mode in ['r', 'l', 'h', 'f'])):
                    # use station platform time and bus time for transfers between rail service and bus service
                    new_link.data2 = (tap['@stplatformtime'] + tap['@stbuswalktime']) / 60
                    new_link['@trantime'] = (tap['@stplatformtime'] + tap['@stbuswalktime']) / 60
                    new_link['@walktime'] = (tap['@stplatformtime'] + tap['@stbuswalktime']) / 60
                elif (mode in ['r', 'l', 'h', 'f']) & (next_mode in ['r', 'l', 'h', 'f']):
                    # use station platform time for transfer between rail modes
                    new_link.data2 = tap['@stplatformtime'] / 60
                    new_link['@trantime'] = tap['@stplatformtime'] / 60
                    new_link['@walktime'] = tap['@stplatformtime'] / 60
                else:
                    print 'mode', mode, 'and new_mode', next_mode, "combination doesn't make sense for tap", tap_id


        # walk transfer links are separated onto separate pseudo taps created in BuildTransitNetworks.job
        # pseudo_tap_id = tap_to_pseudo_tap_xwalk.loc[tap_to_pseudo_tap_xwalk['emme_tap'] == tap_id, 'emme_pseudo_tap']
        # pseudo_tap = network.node(pseudo_tap_id)
        #
        # for walk_link in pseudo_tap.outgoing_links():
        #     if walk_link['@feet'] < max_station_walk_distance:
        #         # setting bus walk times for outgoing walk transfer links
        #         if tap['@stbuswalktime'] > 0:
        #             walk_link['@walktime'] = tap['@stbuswalktime']
        #             walk_link.data2 = tap['@stbuswalktime']  # ul2
        #             bus_transfer_walk_links_overridden.append(walk_link.id)
        #         # setting station platform time only on incoming transfer link to station to avoid double count
        #         # jnode = walk_link.j_node
        #         # modes_serviced = list(set([str(segment.line['#src_mode']) for segment in jnode.outgoing_segments()]))
        #         # if (any(x in modes_serviced for x in ['c', 'l', 'h']) & (tap['@stplatformtime'] > 0)):
        #         #     walk_link['@stnplatformtimewalk'] = tap['@stplatformtime']
        #         #     station_platform_walk_links_set.append(walk_link.id)
        # # setting for incoming links
        # for walk_link in pseudo_tap.incoming_links():
        #     if walk_link['@feet'] < max_station_walk_distance:
        #         if tap['@stbuswalktime'] > 0:
        #             walk_link['@walktime'] = tap['@stbuswalktime']
        #             walk_link.data2 = tap['@stbuswalktime']  # ul2
        #             bus_transfer_walk_links_overridden.append(walk_link.id)

    # print "Number of nodes set with new platform time", len(stop_nodes_with_platform_time)
    # print "Number of walk links set with new walk time", len(bus_transfer_walk_links_overridden)
    print "Number of walk links set with station platform time", len(tap_connectors_with_platform_time)
    # print "Stop nodes with platform time", tap_connectors_with_platform_time

    # test_tap = network.node(4108)
    # print "tap 4108 stnplatformtime: %s" % test_tap['@stnplatformtime']


def create_time_period_scenario(modeller, scenario_id, root, period):
    """
    Calls the indivdual methods that create a scenario for the specified time period
    and populates that scenario with the transit network.  Will create the scenario
    in the Emme project that the modeller is paired with.

    Parameters:
        - modeller: Emme modeller
        - scenario_id: int to denote the unique scenario id
        - root: str specifying folder name containing all of the transaction files
        - period: str specifying time of day period
    Returns:
        - None
    """
    input_dir = _join(root, "emme_network_transaction_files_{}".format(period))
    import_modes(input_dir, modeller, scenario_id)
    import_network(input_dir, modeller, scenario_id)
    import_extra_node_attributes(input_dir, modeller, scenario_id)
    import_extra_link_attributes(input_dir, modeller, scenario_id)
    import_vehicles(input_dir, modeller, scenario_id)
    import_transit_time_functions(input_dir, modeller, scenario_id)
    import_transit_lines(input_dir, modeller, scenario_id)
    import_extra_transit_line_attributes(input_dir, modeller, scenario_id)
    import_extra_transit_segment_attributes(input_dir, modeller, scenario_id)
    import_station_attributes(input_dir, modeller, scenario_id)

    emmebank = modeller.emmebank
    scenario = emmebank.scenario(scenario_id)
    network = scenario.get_network()

    # # replace_route_for_lines_with_nntime_and_created_segments(network, input_dir)
    # # fill_transit_times_for_created_segments(network)
    distribute_nntime(network, input_dir)
    update_transit_times(network)
    calc_link_unreliability(network, period)
    # walktime set in BuildTransitNetworks.job.  999 for non-TRWALK links.
    # fix here is no longer needed
    # fix_bad_walktimes(network)
    scenario.publish_network(network)

    print "applying fares"
    apply_fares = _apply_fares.ApplyFares()
    apply_fares.scenario = scenario
    apply_fares.dot_far_file = _join(root, "fares.far")
    apply_fares.fare_matrix_file = _join(root, "fareMatrix.txt")
    apply_fares.period = period
    apply_fares.execute()

    network = scenario.get_network()
    split_tap_connectors_to_prevent_walk(network)
    scenario.publish_network(network)
    # necessary to get and publish network again???
    network = scenario.get_network()
    apply_station_attributes(input_dir, network)
    scenario.publish_network(network)
    emmebank.dispose()


def update_congested_link_times(modeller, scenario_id, root, period):
    """
    For the first model iteration, the entire network needs to be created. But
    for subsequent iterations, only attributes that change between iterations need
    to be updated.  This essentially just means the congested link times.  Transit
    segments also have their congested transit times updated.

    Parameters:
        - modeller: Emme modeller object for activte project
        - scenario_id: int specifying scenario to update
        - root: str trn folder location containing transaction file folders
        - perdiod: str time of day period
    Returns:
        - None (updates network for specified scenario)
    """
    input_dir = _join(root, "emme_network_transaction_files_{}".format(period))
    emmebank = modeller.emmebank

    print "updating scenario_id %s" % (scenario_id)
    import_extra_link_attributes(input_dir, modeller, scenario_id, update=True)
    import_extra_transit_segment_attributes(input_dir, modeller, scenario_id)

    scenario = emmebank.scenario(scenario_id)
    network = scenario.get_network()
    distribute_nntime(network, input_dir)
    update_transit_times(network)
    scenario.publish_network(network)
    emmebank.dispose()


def connect_to_desktop(port=59673):
    """
    Fetches the Emme desktop object for an already open project. This is a useful
    method when testing a single step or two and you don't want to re-create the entire project.

    Parameters:
        - port: int of the Emme port.  You can find it in Emme under
            tools -> Model Applications -> Advanced
    Returns:
        - Emme desktop object from the specified port
    """
    print("port:", port)
    desktop = _app.connect(port=port)
    return desktop


def start_desktop(root, title="mtc_emme", port=59673):
    """
    Open an emme desktop from the specified emme project folder location

    Parameters:
        - root: str folder location of Emme project
        - title: str name of Emme project folder
        - port: int port number to open the desktop on
    Returns:
        - Emme desktop object
    """
    emme_project = _os.path.join(root, title, title + ".emp")
    desktop = _app.start(  # will not close desktop when program ends
        project=emme_project, user_initials="RSG", visible=True, port=port)
    return desktop


# --------------------------------------------- Entry Point ---------------------------------------
if __name__ == "__main__":
    parser = _argparse.ArgumentParser(description="Create a new Emme project and database with MTC defaults.")
    parser.add_argument('-p', '--trn_path', help=r"path to the trn folder, default is the current_working_folder\trn",
                        default=_join(_os.getcwd(), 'trn'))
    parser.add_argument('-n', '--name', help="the project folder name created in the trn folder, default is mtc_emme",
                        default="mtc_emme")
    parser.add_argument('-i', '--first_iteration', help='Is this the first iteration? yes or no, default is yes', default='yes')
    parser.add_argument('-t', '--time_periods', help='List of time periods as EA,AM,MD,PM,EV or ALL', default='ALL')
    parser.add_argument('-o', '--port', help='Port to connect to Emme desktop session', default=59673, type=int)
    parser.add_argument('-d', '--delete', help='delete / overwrite existing Emme project folder', action='store_true')
    args = parser.parse_args()

    assert (args.first_iteration == 'yes') or (args.first_iteration == 'no'), \
        'Please specify "yes" or "no" for the first_iteration (-i) run-time argument'
    if args.time_periods == "ALL":
        time_periods = _all_periods[:]
    else:
        time_periods = args.time_periods.split(",")
    if args.first_iteration == 'yes':
        # create new emme project folder for the first iteration
        desktop = init_emme_project(args.trn_path, args.name, args.port, args.delete)
        # desktop = connect_to_desktop(port=args.port)
    else:
        # connect to an already created emme project
        try:
            desktop = connect_to_desktop(port=args.port)
        except:
            desktop = start_desktop(args.trn_path, port=args.port)
    # create modeller instance used to import data to project database
    modeller = _m.Modeller(desktop)

    for period in time_periods:
        scenario_id = period_to_scenario_dict[period]
        if args.first_iteration == 'yes':
            print "creating %s scenario" % period
            with _m.logbook_trace("Creating network for %s period " % (period)):
                 create_time_period_scenario(modeller, scenario_id, args.trn_path, period)
        else:
            print "updating %s scenario" % period
            with _m.logbook_trace("Updating network for %s period " % (period)):
                update_congested_link_times(modeller, scenario_id, args.trn_path, period)
